https://bbs.pediy.com/thread-217727.htm

# # 技术概论

## ## 定义

Collberg将混淆描述为一个**从源程序P到混淆后的程序P’的等价转换**。

更精确地说，合法的转换必须要满足以下**两个条件**：如果P终止失败或者异常终止，那么P’可以选择终止或不终止；在其它情况下，P’必须要正常终止，并且产生与P’相同的输出。

这里的输出指的是**用户可观测到的P的行为**，对于那些不可观测到的行为，如创建文件与访问网络等，都是可以在合法转换中出现的

## ## 分类

目前使用最广泛的混淆分类方式是Collberg于1997年针对JAVA程序的安全问题提出的

按照Collberg的定义，混淆可以分为以下四种类型：

### 1 布局混淆

删除或修改源代码中的对攻击者有利的信息，如变量名、调试信息等。

### 2 预防性混淆

指预先针对特定的反编译工具、解混淆方法进行防备。

### 3 控制混淆

是目前研究的重点。

控制混淆的**分类**：聚合、排序、计算。

- **聚合**：将逻辑上相干的计算**分割**，或者将逻辑上不相干的计算**聚合**在一起。
- **排序**：将计算在程序中的**分布**随机化处理。
- **计算：**插入**混淆计算代码**来隐藏真实的控制流，包括扩展循环条件，引入不透明谓词等。

### 4 数据混淆

分类：==聚合、重组、编码==。



# # 常见混淆策略

## 一、基于数据流

### 1 ==指令移动==

将基本块内的语句进行顺序重排。

### 2 插入死代码 ==属于哪块分类==

**死代码：**

永远不会被用到的代码。

**思路：**

在两个基本块之间，或者在一个基本块里强行划出两个基本块（强行随机选择首地址），本应该有一条**无条件转移指令**来连接它们。我们可以伪造一条**条件跳转指令**，但是有效的，永远是两侧分支中的一支（另一侧就是死代码）。如果更近一步，可以用这些死代码进行巧妙构造来对抗静态反汇编工具。

**不让破解者轻易发现这是==伪造的基本块==：**

引入一些必然成立的数学公式（或者在某个范围上必然成立）

eg： $a^2 + b^2 >= 2ab   $

$  (a^2＋b^2)(c^2 + d^2)≥(ac+bd)^2$   

### 3 常量展开

常量合并的逆操作。编译器在编译时，会把那些在每次运行时总是得到相同常量值的表达式替换为该常量值。

+下面这段代码，在现代编译器中，不会把`5*7+10`这个计算过程编译进**目标程序**，因为这个值在编译时就可以推算出来。

```
int a;
a = 5 * 7 + 10;
```

==对代码进行混淆时，我们可以提取出一些指令的立即数，对其进行展开。忽略标志性的变化，下面的两端代码完全等价：==

```
push 2
```

```
push 1
inc dword ptr[esp],1
```



### 4 数据存储、编码

### 5 恒等运算替换

x - 1 == ~-x
x + 1 == -x
ror x,y == x >> y | (x << (lenbite(x) - y))
rol x,y ==x << y | (x >> (lenbite(x) - y))

lenbite指取位数，比如DWORD取位数是32 

==下面两条指令完全等价==：

```
not reg32
```

```
xor reg32,-1
```



### 6 模式替换

==窥孔优化的逆操作==

下述代码完全等价：

```
push x
```

```
lea esp,[esp - 4]
mov [esp],x
```

下述代码完全等价：

```
lea esp,[esp - 4]
```

```
push reg32
mov reg32,esp
xchg [reg32],esp
pop esp
```

**优势：**这项技术的可怕在于，这个过程是可以不断重复的。混淆了一次代码，可能会有新的可以混淆的代码出现，从而不断迭代。

**破解：**破解相对容易，只要搜集到足够多的模板，对其替换回来就好，即编写高阶模式匹配器。

### 7 常量隐藏



## 二、基于控制流

### 1 函数内联

### 2 函数外联

### 3 混合



## 三、基于控制流与数据流

### 1 不透明谓词

### 2 路径分支信息隐藏

### 3 控制流平坦



# # 应用

## 一、基于二进制代码实现混淆器

### 1 静态分析方法

### 2 栈分析

### 3 活跃分析